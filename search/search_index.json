{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LancerShield Documentation","text":"<p>Welcome to the official documentation hub for LancerShield - your AI-powered platform for smart contract auditing, vulnerability detection, and secure development.</p>"},{"location":"#what-youll-find-here","title":"What You'll Find Here","text":"<ul> <li> <p>\ud83d\udd0d Severity Framework   Understand our standardized classification system (LSF) for ranking vulnerabilities from Informational to Critical.</p> </li> <li> <p>\ud83e\udde0 Vulnerability Database   Explore real-world vulnerability patterns, categorized with before/after code, causes, and preventions.</p> </li> <li> <p>\ud83e\udd1d Contributing Guide   Help us expand the open knowledge base. Learn how to submit new vulnerabilities, improvements, and fixes.</p> </li> </ul>"},{"location":"#why-lancershield","title":"Why LancerShield?","text":"<p>Smart contract security is critical - and costly to get wrong. LancerShield aims to modernize smart contract security with an integrated approach that combines:</p> <ul> <li>Automated Vulnerability Detection - Static analysis with low false positives, powered by Slither and enhanced by AI reasoning.</li> <li>Function-Level CVR (Causal Vulnerability Reasoning) - AI-generated explanations that trace exploit chains and identify root causes.</li> <li>Confidence-Scored Findings - Every issue is rated with a certainty level and reasoning, so you know where to focus.</li> <li>Developer-Friendly Fixes &amp; Docs - Clear, editable fix suggestions and markdown audit reports you can act on immediately.</li> </ul> <p>Whether you're a solo dev or a protocol team, this documentation is your open knowledge foundation.</p> <p>\ud83d\udee1\ufe0f Securing Web3 - One line of code at a time.</p>"},{"location":"contributing/","title":"Contributing to LancerShield Docs","text":"<p>Thank you for your interest in contributing to the LancerShield open documentation initiative!</p> <p>This project is designed to create a structured, trustworthy, and community-driven resource for smart contract auditing knowledge.</p>"},{"location":"contributing/#what-you-can-contribute","title":"\u270d\ufe0f What You Can Contribute","text":"<ul> <li>\ud83d\udc1e Add new vulnerabilities with descriptions, examples, causes, and fixes.</li> <li>\ud83d\udee0\ufe0f Suggest better secure coding patterns or best practices.</li> <li>\ud83d\udcda Report errors, outdated practices, or unclear explanations.</li> </ul>"},{"location":"contributing/#folder-structure","title":"\ud83d\udcc1 Folder Structure","text":"<p>All docs live under the <code>docs/</code> directory.</p> <ul> <li><code>severity-framework/</code> - scoring system and color-coded severity breakdown</li> <li><code>vuln-db/</code> - vulnerability entries grouped by severity and category</li> <li><code>contributing/</code> - this guide and submission instructions</li> </ul>"},{"location":"contributing/#vulnerability-entry-format","title":"\ud83e\uddfe Vulnerability Entry Format","text":"<p>Each entry should include:</p> <ul> <li>A short title</li> <li>Assigned severity level (using LSF)</li> <li>Clear description of the vulnerability</li> <li>Vulnerable code snippet (before)</li> <li>Exploit scenario (how it can be abused)</li> <li>A fixed code snippet (after)</li> <li> <p>Best practice advice or links (optional)</p> </li> <li> <p>\ud83e\udde9 You must follow the official template when submitting any new vulnerability. This ensures consistency, proper indexing, and readability across the documentation.</p> </li> </ul> <p>Example filename: <code>vuln-db/critical/reentrancy-classic.md</code></p>"},{"location":"contributing/#how-to-submit","title":"\ud83d\udce4 How to Submit","text":"<ol> <li>Fork this repo</li> <li>Create a new branch</li> <li>Add or edit Markdown files</li> <li>Open a pull request (PR)</li> <li>Use our PR template and explain your changes clearly</li> </ol>"},{"location":"contributing/#contribution-standards","title":"\u2705 Contribution Standards","text":"<ul> <li>Be concise and specific.</li> <li>Prefer real-world examples (from public exploits).</li> <li>Follow the folder structure and formatting style.</li> <li>Credit original sources if referencing external material.</li> <li>\u26a0\ufe0f The LancerShield Severity Framework (LSF) is a core scoring protocol and cannot be modified via direct pull requests.   If you'd like to suggest improvements to the LSF, please open a GitHub Issue instead.</li> </ul>"},{"location":"contributing/#join-the-mission","title":"\ud83e\udd1d Join the Mission","text":"<p>We believe security knowledge should be accessible, auditable, and extensible. Help us raise the bar for smart contract safety \u2014 one documented vulnerability at a time.</p> <p>- The LancerShield Team</p>"},{"location":"severity-framework/","title":"LancerShield Severity Framework (LSF)","text":"<p>The LancerShield Severity Framework (LSF) provides a structured, consistent, and explainable way to rate vulnerabilities discovered during smart contract audits. It enables better prioritization, automation, and trust in the audit process.</p>"},{"location":"severity-framework/#severity-levels","title":"Severity Levels","text":"Code Label Meaning C Critical Direct fund loss, contract destruction, or irreversible control loss H High Significant theft, denial-of-service, or unauthorized state changes M Medium Conditional exploit requiring specific inputs or edge case setup L Low Minor issues, unlikely to be exploited or low impact I Informational No impact - readability, style, or developer notes G Gas Gas inefficiencies only, no security or functional risk"},{"location":"severity-framework/#scoring-criteria-axis","title":"Scoring Criteria (Axis)","text":"<p>Each issue is scored across five axis from 0\u20135, with weighted importance.</p> Axis Weight Scope Impact 40% Severity of damage if exploited Exploitability 25% Ease of triggering the bug Reachability 15% Can the code path actually be reached? Complexity 10% Setup effort or attacker sophistication required Detectability 10% How likely is this to be missed during review? <p>\ud83d\udd12 Impact or Reachability of 0 auto-downgrades severity to Informational.</p>"},{"location":"severity-framework/#severity-calculation-logic","title":"Severity Calculation Logic","text":""},{"location":"severity-framework/#weighted-score-severity-mapping","title":"Weighted Score \u2192 Severity Mapping:","text":"Final Score Severity 4.5 - 5.0 Critical (C) 3.5 - 4.49 High (H) 2.5 - 3.49 Medium (M) 1.5 - 2.49 Low (L) 0 - 1.49 Informational (I)"},{"location":"severity-framework/#severity-level-scope","title":"Severity Level Scope","text":""},{"location":"severity-framework/#critical-c","title":"Critical (C)","text":"<ul> <li>Scope: Catastrophic impact (e.g. loss of control, fund drains)</li> <li>Must be fixed before deployment</li> <li>Color Code:  <code>#D32F2F</code></li> </ul>"},{"location":"severity-framework/#high-h","title":"High (H)","text":"<ul> <li>Scope: Major financial or functional impact</li> <li>Should be fixed before mainnet</li> <li>Color Code:  <code>#F57C00</code></li> </ul>"},{"location":"severity-framework/#medium-m","title":"Medium (M)","text":"<ul> <li>Scope: Exploitable with effort, medium-risk</li> <li>Fix recommended; acceptable in staging</li> <li>Color Code:  <code>#FBC02D</code></li> </ul>"},{"location":"severity-framework/#low-l","title":"Low (L)","text":"<ul> <li>Scope: Low impact or unlikely execution</li> <li>Fix if convenient</li> <li>Color Code:  <code>#388E3C</code></li> </ul>"},{"location":"severity-framework/#informational-i","title":"Informational (I)","text":"<ul> <li>Scope: No security or runtime effect</li> <li>No fix needed, but improves readability</li> <li>Color Code:  <code>#1976D2</code></li> </ul>"},{"location":"severity-framework/#gas-g","title":"Gas (G)","text":"<ul> <li>Scope: Optimizations only</li> <li>No functional or security effect</li> <li>Color Code:  <code>#616161</code></li> </ul>"},{"location":"severity-framework/#override-audit-logging","title":"Override + Audit Logging","text":"<p>Auditors may override the computed severity with justification. All overrides are recorded with user ID, timestamp, and cryptographic hash for transparency.</p> <p>The LancerShield Severity Framework (LSF) is still under refinement. Additional override logic and edge-case rules are being continuously evaluated based on real-world audit data.</p>"},{"location":"vuln-db/","title":"\ud83d\udc1e Vulnerability Database","text":"<p>This is the official open knowledge base of real-world smart contract vulnerabilities curated by the LancerShield community.</p> <p>Each entry contains:</p> <ul> <li>A structured metadata frontmatter</li> <li>Human-readable explanation</li> <li>Minimal working examples of the vulnerable and fixed code</li> <li>Exploit scenario and prevention strategies</li> </ul>"},{"location":"vuln-db/#categories","title":"\ud83d\udcc2 Categories","text":"<p>Vulnerabilities are grouped under severity levels using the LancerShield Severity Framework:</p> <ul> <li>Critical (C) \u2013 Total fund loss, contract destruction, or irreversible takeover</li> <li>High (H) \u2013 Large-scale theft or persistent unauthorized access</li> <li>Medium (M) \u2013 Exploitable under certain conditions or state assumptions</li> <li>Low (L) \u2013 Minor misbehavior or best-practice violations</li> <li>Informational (I) \u2013 Non-exploitable or stylistic notes</li> <li>Gas (G) \u2013 Optimization opportunities, not security flaws</li> </ul>"},{"location":"vuln-db/#contributing","title":"\ud83e\udde0 Contributing","text":"<p>Want to contribute a new vulnerability?</p> <ul> <li>Use the template to format your submission</li> <li>Follow the contribution guide</li> <li>Submit via Pull Request \u2014 our reviewers will validate and merge after review</li> </ul>"},{"location":"vuln-db/#future-use","title":"\ud83d\udee0 Future Use","text":"<p>This database will serve as:</p> <ul> <li>A source of training data for LancerShield\u2019s CVR engine</li> <li>A public archive of Web3\u2019s most critical and preventable security incidents</li> <li>A shared standard to help educate and secure the smart contract ecosystem</li> </ul>"},{"location":"vuln-db/template/","title":"Title of the vulnerability","text":"<pre><code>id: TBA  # Leave this as \"TBA\"; the team will assign the official ID\ntitle: Example Vulnerability Title\nseverity: M # Options: C | H | M | L | I | G\ncategory: access-control\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Unauthorized asset withdrawal\nstatus: draft # Options: draft | verified | published\ncomplexity: low # Options: low | medium | high\nattack_vector: external\nmitigation_difficulty: easy # Options: easy | medium | hard\nversions: [\"&gt;0.6.0\", \"&lt;0.8.0\"]\ncwe: CWE-284\nswc: SWC-105\n</code></pre>"},{"location":"vuln-db/template/#description","title":"\ud83d\udcdd Description","text":"<p>Explain the vulnerability in clear terms. Focus on:</p> <ul> <li>What fundamental flaw creates this vulnerability</li> <li>Where this pattern commonly appears in smart contracts</li> <li>Why this vulnerability is dangerous (technical impact)</li> </ul>"},{"location":"vuln-db/template/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>// Replace with a minimal, complete example\nfunction withdraw(uint amount) public {\n    require(balances[msg.sender] &gt;= amount);\n    (bool sent, ) = msg.sender.call{value: amount}(\"\");\n    require(sent);\n    balances[msg.sender] -= amount;\n}\n</code></pre>"},{"location":"vuln-db/template/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<p>Step-by-step exploit process:</p> <ol> <li>Attacker deploys a malicious contract that...</li> <li>The attacker then calls...</li> <li>During execution, the vulnerable contract...</li> <li>This allows the attacker to...</li> </ol> <p>Assumptions: List any prerequisites for the attack</p>"},{"location":"vuln-db/template/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>// Safer implementation\nfunction withdraw(uint amount) public {\n    require(balances[msg.sender] &gt;= amount);\n    balances[msg.sender] -= amount;\n    (bool sent, ) = msg.sender.call{value: amount}(\"\");\n    require(sent);\n}\n</code></pre>"},{"location":"vuln-db/template/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/template/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Most important prevention technique</li> <li>Second most important technique</li> </ul>"},{"location":"vuln-db/template/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Additional defensive measures</li> <li>Testing approaches</li> </ul>"},{"location":"vuln-db/template/#detection-methods","title":"Detection Methods","text":"<ul> <li>How to detect this issue in existing code</li> <li>Tools that can help identify this vulnerability</li> </ul>"},{"location":"vuln-db/template/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<p>Case studies, notable incidents, or real-world examples relevant to this vulnerability.</p>"},{"location":"vuln-db/template/#further-reading","title":"\ud83d\udcda Further Reading","text":"<p>Additional resources, tools, or discussions related to this vulnerability.</p>"},{"location":"vuln-db/template/#vulnerability-report-template","title":"\u2705 Vulnerability Report Template","text":"<pre><code>id: &lt;unique-vulnerability-id&gt;\ntitle: &lt;vulnerability-title&gt;\nseverity: &lt; H | M | L | I | G&gt;\nscore:\nimpact: &lt;0-5&gt;\nexploitability: &lt;0-5&gt;\nreachability: &lt;0-5&gt;\ncomplexity: &lt;0-5&gt;\ndetectability: &lt;0-5&gt;\nfinalScore: &lt;calculated-weighted-score&gt;\n</code></pre>"},{"location":"vuln-db/template/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<p>Provide technical rationales for each axis score here:</p> <ul> <li>Impact: [Explain why this bug would (or wouldn\u2019t) cause financial/state loss]</li> <li>Exploitability: [Clarify the conditions under which this can be triggered]</li> <li>Reachability: [Is the code path realistically invoked? Any blockers?]</li> <li>Complexity: [How much attacker effort, knowledge, or setup is required?]</li> <li>Detectability: [Would this be caught in a standard audit pipeline?]</li> </ul>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/","title":"Flash Loan Attacks","text":"<pre><code>id: TBA\ntitle: Flash Loan Exploit on Atomic Lending Operations\nseverity: C\ncategory: flash-loan\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Arbitrary manipulation of protocol logic and state within a single transaction\nstatus: draft\ncomplexity: medium\nattack_vector: external\nmitigation_difficulty: hard\nversions: [\"&gt;=0.6.0\", \"&lt;0.8.21\"]\ncwe: CWE-346\nswc: SWC-108\n</code></pre>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#description","title":"\ud83d\udcdd Description","text":"<ul> <li>Flash loan attacks occur when a protocol allows a user to borrow large amounts of tokens within a single atomic transaction (a \"flash loan\") and the protocol being exploited fails to account for the possibility of state manipulation or reentry before loan repayment. </li> <li>This allows an attacker to manipulate pricing, collateral, governance votes, or liquidity pools within the same transaction before repaying the loan\u2014making the attack costless and highly capital-efficient.</li> </ul>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>interface IFlashLoanProvider {\n    function flashLoan(uint256 amount) external;\n}\n\ncontract VulnerableVault {\n    uint256 public totalDeposits;\n    mapping(address =&gt; uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        totalDeposits += msg.value;\n    }\n\n    function withdraw() external {\n        uint256 share = balances[msg.sender] / totalDeposits;\n        uint256 reward = address(this).balance * share;\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(reward);\n    }\n}\n</code></pre>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<p>Step-by-step exploit process:</p> <ul> <li>Attacker takes a flash loan for a large amount of ETH.</li> <li>Deposits the ETH into the vulnerable contract.</li> <li>totalDeposits increases sharply, skewing share calculations.</li> <li>Immediately withdraws with an inflated reward value.</li> <li>Repays flash loan, keeping the profit.</li> </ul> <p>Assumptions:</p> <ul> <li>No mechanism to differentiate real deposits vs. atomic inflows.</li> <li>Arithmetic uses transient state that can be manipulated within a single transaction.</li> </ul>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>function withdraw() external {\n    require(tx.origin == msg.sender, \"No contract calls\");\n    require(balances[msg.sender] &gt; 0, \"Nothing to withdraw\");\n\n    uint256 userBalance = balances[msg.sender];\n    balances[msg.sender] = 0;\n    totalDeposits -= userBalance;\n\n    payable(msg.sender).transfer(userBalance);\n}\n</code></pre>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/critical/Flash-Loan-Attacks/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Do not rely on address(this).balance or totalDeposits during the same transaction.</li> <li>Use snapshot-based accounting or block-delayed updates.</li> <li>Add flash loan-resistant mechanisms (e.g., accrue rewards over multiple blocks).</li> </ul>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Use tx.origin to restrict contracts (with caveats).</li> <li>Integrate flash loan-aware oracles with TWAPs.</li> <li>Introduce rate limits, circuit breakers, or oracle price sanity checks.</li> </ul>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#detection-methods","title":"Detection Methods","text":"<ul> <li>Symbolic testing of temporal state assumptions.</li> <li>Fuzzing with atomic transaction bundles.</li> <li>Manual audit of areas involving price, votes, or collateral checks.</li> </ul>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<ul> <li>Name: bZx Protocol Flash Loan Attack</li> <li>Date: 2020-02-15 </li> <li>Loss: ~$350K </li> <li> <p>Post-mortem: Link to post-mortem - </p> </li> <li> <p>Name: Alpha Homora / Cream Exploit </p> </li> <li>Date: 2021-02-13 </li> <li>Loss: ~$37.5M </li> <li>Post-mortem: Link to post-mortem </li> </ul>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>SWC-108: Untrusted Delegate Call or Flash Loan </li> <li>OpenZeppelin \u2013 Flash Loan Security </li> <li>Certora \u2013 Flash Loan Vulnerability Modeling </li> </ul>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#vulnerability-report","title":"\u2705 Vulnerability Report","text":"<pre><code>id: TBA\ntitle: Flash Loan Attacks\nseverity: C\nscore:\nimpact: 5         \nexploitability: 5 \nreachability: 4   \ncomplexity: 3     \ndetectability: 3  \nfinalScore: 4.5\n</code></pre>"},{"location":"vuln-db/critical/Flash-Loan-Attacks/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<ul> <li>Impact: Can completely drain vaults, manipulate markets, or corrupt governance.</li> <li>Exploitability: Publicly accessible via free capital from flash loan providers.</li> <li>Reachability: Most DeFi lending and AMM protocols expose price-sensitive logic.</li> <li>Complexity: Moderate; needs scripting and test environment simulation.</li> <li>Detectability: Missed by tools unless temporal flows and state coupling are explicitly modeled.</li> </ul>"},{"location":"vuln-db/critical/Overview/","title":"\ud83d\udd25 Critical Severity","text":"<ul> <li> <p>Represents the highest risk level in vulnerability classification.</p> </li> <li> <p>Exploits can lead to complete loss of funds, contract bricking, or governance takeover.</p> </li> <li> <p>Vulnerabilities are often immediately exploitable post-deployment.</p> </li> <li> <p>Impact affects not only individual users but entire protocols and ecosystems.</p> </li> <li> <p>These issues must be patched immediately\u2014delays can be catastrophic.</p> </li> <li> <p>Exploits are typically irreversible on-chain, leading to permanent damage.</p> </li> <li> <p>Attackers may gain full admin control or bypass all user restrictions.</p> </li> <li> <p>Often result in protocol shutdowns, forks, or emergency withdrawals.</p> </li> <li> <p>May attract legal, regulatory, or reputational fallout.</p> </li> <li> <p>Examples: reentrancy flaws, logic bugs in withdrawal functions, broken access control.</p> </li> </ul>"},{"location":"vuln-db/critical/Price-oracle/","title":"Price Oracle Manipulation","text":"<pre><code>id: TBA\ntitle: Price Oracle Manipulation\nseverity: C\ncategory: oracle-manipulation\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Mispriced trades, loans, and liquidations\nstatus: draft\ncomplexity: medium\nattack_vector: external\nmitigation_difficulty: medium\nversions: [\"&gt;=0.4.0\", \"&lt;0.8.21\"]\ncwe: CWE-345\nswc: SWC-114\n</code></pre>"},{"location":"vuln-db/critical/Price-oracle/#description","title":"\ud83d\udcdd Description","text":"<ul> <li>Price Oracle Manipulation occurs when an attacker influences the data source a smart contract relies on for pricing assets. </li> <li>If the oracle uses manipulable inputs\u2014such as on-chain DEX prices, thin liquidity pools, or manipulable off-chain data feeds\u2014an attacker can trick the contract into believing an incorrect asset price. </li> <li>This results in faulty calculations in lending protocols, AMMs, liquidations, and more.</li> </ul>"},{"location":"vuln-db/critical/Price-oracle/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>interface IPriceFeed {\n    function getPrice(address token) external view returns (uint);\n}\n\ncontract Lending {\n    IPriceFeed public oracle;\n    mapping(address =&gt; uint256) public collateral;\n\n    constructor(address _oracle) {\n        oracle = IPriceFeed(_oracle);\n    }\n\n    function borrow(address token, uint256 amount) external {\n        uint256 price = oracle.getPrice(token);\n        require(collateral[msg.sender] * price &gt;= amount, \"Undercollateralized\");\n        // Issue loan logic\n    }\n}\n</code></pre>"},{"location":"vuln-db/critical/Price-oracle/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<p>Step-by-step exploit process:</p> <ol> <li>Attacker identifies that the price feed uses a low-liquidity AMM pair.</li> <li>Attacker performs large buy/sell to skew the price of the token.</li> <li>Calls borrow() using artificially inflated collateral value.</li> <li>Withdraws loaned tokens at the manipulated price, then reverses the price manipulation.</li> </ol> <p>Assumptions:</p> <ul> <li> <p>Oracle is based on TWAP or spot price of an AMM like Uniswap with low liquidity.</p> </li> <li> <p>Borrow/loan logic relies directly on unverified price inputs.</p> </li> </ul>"},{"location":"vuln-db/critical/Price-oracle/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>contract SaferLending {\n    IPriceFeed public chainlinkOracle;\n\n    constructor(address _oracle) {\n        chainlinkOracle = IPriceFeed(_oracle);\n    }\n\n    function borrow(address token, uint256 amount) external {\n        uint256 price = chainlinkOracle.getPrice(token); // Uses secure, external oracle\n        require(price &gt; 0, \"Invalid price\");\n        // Collateral logic...\n    }\n}\n</code></pre>"},{"location":"vuln-db/critical/Price-oracle/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/critical/Price-oracle/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Use decentralized oracles like Chainlink, Redstone, or UMA.</li> <li>Rely on TWAPs with sufficient duration to avoid short-term manipulation.</li> <li>Avoid direct use of low-liquidity AMM pairs as price feeds.</li> </ul>"},{"location":"vuln-db/critical/Price-oracle/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Add circuit breakers or sanity checks on extreme price changes.</li> <li>Use multi-oracle aggregation with median or weighted average logic.</li> <li>Consider governance delays for price-sensitive operations.</li> </ul>"},{"location":"vuln-db/critical/Price-oracle/#detection-methods","title":"Detection Methods","text":"<ul> <li>Analyze oracle dependency and source trustworthiness.</li> <li>Use Slither detectors for untrusted-oracle and price-manipulation.</li> <li>Simulate oracle price impact with fuzzing or adversarial testing.</li> </ul>"},{"location":"vuln-db/critical/Price-oracle/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<ul> <li>Name: Synthetix sKRW Oracle Exploit </li> <li>Date: 2019-06-25 </li> <li>Loss: $1B (reversed) </li> <li> <p>Post-mortem: Link to post-mortem </p> </li> <li> <p>Name: Harvest Finance Exploit</p> </li> <li>Date: 2020-10-26 </li> <li>Loss: ~$33M </li> <li> <p>Post-mortem: Link to post-mortem </p> </li> <li> <p>Name: Mango Markets Manipulation </p> </li> <li>Date: 2022-10-11 </li> <li>Loss: ~$114M </li> <li>Post-mortem: Link to post-mortem --&gt;</li> </ul>"},{"location":"vuln-db/critical/Price-oracle/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>SWC-114: Oracle Manipulation </li> <li>Chainlink \u2013 Preventing Oracle Attacks </li> <li>Paradigm Research \u2013 Oracle Manipulation in DeFi </li> </ul>"},{"location":"vuln-db/critical/Price-oracle/#vulnerability-report","title":"\u2705 Vulnerability Report","text":"<pre><code>id: TBA\ntitle: Price Oracle Manipulation\nseverity: C\nscore:\nimpact: 5         \nexploitability: 5 \nreachability: 4   \ncomplexity: 3     \ndetectability: 3  \nfinalScore: 4.5\n</code></pre>"},{"location":"vuln-db/critical/Price-oracle/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<ul> <li> <p>Impact: Can directly lead to protocol insolvency or massive bad debt.</p> </li> <li> <p>Exploitability: Commonly exploitable on thin-liquidity pairs or unverified TWAPs.</p> </li> <li> <p>Reachability: Oracle data is usually directly queried in user-facing functions.</p> </li> <li> <p>Complexity: Requires moderate setup (manipulate AMM pool or data feed).</p> </li> <li> <p>Detectability: Detectable in code reviews, but often missed in data flow audits.</p> </li> </ul>"},{"location":"vuln-db/high/Access-control/","title":"Access Control Vulnerabilities","text":"<pre><code>id: TBA\ntitle:  Access Control on Sensitive Functions\nseverity: H\ncategory: access-control\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Unauthorized state or asset manipulation\nstatus: draft\ncomplexity: medium\nattack_vector: external\nmitigation_difficulty: easy\nversions: [\"&gt;=0.4.0\", \"&lt;0.8.21\"]\ncwe: CWE-284\nswc: SWC-105\n</code></pre>"},{"location":"vuln-db/high/Access-control/#description","title":"\ud83d\udcdd Description","text":"<ul> <li>Access control vulnerabilities occur when critical functions\u2014such as fund withdrawals, admin configuration, or token minting\u2014lack proper permission checks. </li> <li>In Ethereum smart contracts, this often results from failing to restrict access with <code>onlyOwner</code>, role-based modifiers, or faulty logic in <code>msg.sender</code> comparisons. </li> <li>Attackers can exploit these flaws to gain unauthorized control over privileged operations.</li> </ul>"},{"location":"vuln-db/high/Access-control/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>contract Vault {\n    address public admin;\n    mapping(address =&gt; uint256) public balances;\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function withdrawAll() external {\n        payable(msg.sender).transfer(address(this).balance); // No access check\n    }\n\n    function setAdmin(address _newAdmin) external {\n        admin = _newAdmin; // Anyone can call this\n    }\n}\n</code></pre>"},{"location":"vuln-db/high/Access-control/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<p>Step-by-step exploit process:</p> <ol> <li>Attacker calls setAdmin() and sets themselves as the admin.</li> <li>Attacker then calls withdrawAll() and drains the contract balance.</li> <li>No access checks prevent unauthorized access to critical logic.</li> </ol> <p>Assumptions:</p> <ul> <li>No onlyOwner/require(msg.sender == admin) present.</li> <li>No role-based access control using AccessControl or similar libraries.</li> </ul>"},{"location":"vuln-db/high/Access-control/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>contract SecureVault is Ownable {\n    constructor() {\n        transferOwnership(msg.sender);\n    }\n\n    function withdrawAll() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        transferOwnership(_newAdmin);\n    }\n}\n</code></pre>"},{"location":"vuln-db/high/Access-control/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/high/Access-control/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Use OpenZeppelin\u2019s Ownable or AccessControl libraries.</li> <li>Enforce onlyOwner or onlyRole modifiers on privileged functions.</li> <li>Validate msg.sender against trusted addresses before sensitive actions.</li> </ul>"},{"location":"vuln-db/high/Access-control/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Consider multi-sig wallets for admin operations.</li> <li>Use timelocks for critical governance updates.</li> <li>Monitor on-chain admin function calls.</li> </ul>"},{"location":"vuln-db/high/Access-control/#detection-methods","title":"Detection Methods","text":"<ul> <li>Slither: access-control, missing-authorization detectors.</li> <li>MythX, Mythril: symbolic analysis of control flow and privilege escalations.</li> <li>Manual auditing with threat modeling and function-level review.</li> </ul>"},{"location":"vuln-db/high/Access-control/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<ul> <li>Name: Rubixi Ownership Bug </li> <li>Date: 2016-05-03 </li> <li>Loss: N/A </li> <li> <p>Post-mortem: Link to post-mortem </p> </li> <li> <p>Name: bZx Protocol Admin Misconfiguration </p> </li> <li>Date: 2020-02-15 </li> <li>Loss: $350K </li> <li>Post-mortem: Link to post-mortem</li> </ul>"},{"location":"vuln-db/high/Access-control/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>SWC-105: Unprotected Critical Function</li> <li>OpenZeppelin: Access Control Best Practices</li> <li>Trail of Bits: Access Control Patterns </li> </ul>"},{"location":"vuln-db/high/Access-control/#vulnerability-report","title":"\u2705 Vulnerability Report","text":"<pre><code>id: vuln__001\ntitle: Access Control Vulnerabilities\nseverity: H\nscore:\nimpact: 5         \nexploitability: 4 \nreachability: 4   \ncomplexity: 2     \ndetectability: 4  \nfinalScore: 4.2\n</code></pre>"},{"location":"vuln-db/high/Access-control/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<ul> <li> <p>Impact: Loss of control, unauthorized withdrawals, or contract destruction.</p> </li> <li> <p>Exploitability: One call to an unprotected admin function can cause catastrophic failure.</p> </li> <li> <p>Reachability: Admin-like functions are usually public or external.</p> </li> <li> <p>Complexity: Little to no complexity if permission checks are missing.</p> </li> <li> <p>Detectability: Well-known tools like Slither and Mythril detect most access issues, but subtle logic bugs may evade detection.</p> </li> </ul>"},{"location":"vuln-db/high/Improper-Upgradeability/","title":"Improper Upgradeability","text":"<pre><code>id: TBA\ntitle: Improper Upgradeability Leading to Storage Corruption or Unauthorized Logic Control\nseverity: H\ncategory: upgradeability\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Permanent contract malfunction or unauthorized control\nstatus: draft\ncomplexity: medium\nattack_vector: external\nmitigation_difficulty: hard\nversions: [\"&gt;=0.5.0\", \"&lt;0.8.21\"]\ncwe: CWE-694\nswc: SWC-112\n</code></pre>"},{"location":"vuln-db/high/Improper-Upgradeability/#description","title":"\ud83d\udcdd Description","text":"<ul> <li>Improper upgradeability refers to flaws in upgradable smart contract systems (e.g., proxy patterns) where either the storage layout is misaligned between proxy and implementation, or the upgrade logic is left exposed to unauthorized parties. </li> <li>This can cause storage collisions, logic corruption, or even complete loss of control over the proxy contract. -Improper handling of <code>delegatecall</code> or <code>admin</code> storage slots is especially dangerous in patterns like UUPS and Transparent proxies if not implemented using hardened libraries.</li> </ul>"},{"location":"vuln-db/high/Improper-Upgradeability/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>// Simplified proxy example with unprotected upgrade\ncontract Proxy {\n    address public implementation;\n\n    fallback() external payable {\n        address impl = implementation;\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    function upgradeTo(address _newImpl) external {\n        implementation = _newImpl; // \u274c No access control\n    }\n}\n</code></pre>"},{"location":"vuln-db/high/Improper-Upgradeability/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<p>Step-by-step exploit process:</p> <ol> <li>Attacker calls upgradeTo() and points the proxy to their malicious implementation.</li> <li>All future calls to the proxy are now delegated to attacker code.</li> <li>Attacker can steal funds, disable the contract, or overwrite critical state.</li> </ol> <p>Assumptions: - Upgrade function is public or not gated with onlyOwner or onlyProxyAdmin. - Implementation contract has unaligned storage or logic.</p>"},{"location":"vuln-db/high/Improper-Upgradeability/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>import \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SafeProxyAdmin is Ownable {\n    function upgrade(address proxy, address newImplementation) external onlyOwner {\n        TransparentUpgradeableProxy(payable(proxy)).upgradeTo(newImplementation);\n    }\n}\n</code></pre>"},{"location":"vuln-db/high/Improper-Upgradeability/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/high/Improper-Upgradeability/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Use OpenZeppelin Proxy libraries (UUPS, TransparentProxy) with hardened admin logic.</li> <li>Lock and restrict upgrade functions (onlyOwner, onlyProxyAdmin).</li> <li>Maintain strict storage layout discipline between implementation versions.</li> </ul>"},{"location":"vuln-db/high/Improper-Upgradeability/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Use storage gaps in inherited contracts for future-safe upgrades.</li> <li>Add on-chain version checks and rollback mechanisms.</li> <li>Use test tools like hardhat-upgrades to simulate layout compatibility.</li> </ul>"},{"location":"vuln-db/high/Improper-Upgradeability/#detection-methods","title":"Detection Methods","text":"<ul> <li>Slither: unprotected-upgrade, delegatecall misuse detectors.</li> <li>Manual audit of fallback logic and delegatecall boundaries.</li> <li>Bytecode diffing and layout validation between upgrades.</li> </ul>"},{"location":"vuln-db/high/Improper-Upgradeability/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<ul> <li>Name: Parity Wallet Library Self-Destruct </li> <li>Date: 2017-11-06 </li> <li>Loss: ~$150M frozen </li> <li> <p>Post-mortem: Link to post-mortem </p> </li> <li> <p>Name: ProxyAdmin Exposure in Upbit Token </p> </li> <li>Date: 2022-01-18 </li> <li>Loss: N/A (whitehat discovered) </li> <li>Post-mortem: Link to post-mortem</li> </ul>"},{"location":"vuln-db/high/Improper-Upgradeability/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>SWC-112: Delegatecall to Untrusted Callee </li> <li>OpenZeppelin \u2013 Upgrades Plugins &amp; Guides </li> <li>Trail of Bits \u2013 Secure Upgrade Patterns --&gt;</li> </ul> <pre><code>id: TBA\ntitle: Improper Upgradeability \nseverity: H\nscore:\nimpact: 5        \nexploitability: 4 \nreachability: 4   \ncomplexity: 3     \ndetectability: 3  \nfinalScore: 4.3\n</code></pre>"},{"location":"vuln-db/high/Improper-Upgradeability/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<ul> <li>Impact: Entire protocol can be hijacked, frozen, or misdirected via malicious logic.</li> <li>Exploitability: Simple if upgrade functions are exposed or poorly controlled.</li> <li>Reachability: Proxy contracts typically expose fallback and upgrade paths.</li> <li>Complexity: Moderate; requires constructing a compatible attacker implementation.</li> <li>Detectability: Easily flagged if unsafe proxy patterns are used, but subtle layout misalignments may escape detection.</li> </ul>"},{"location":"vuln-db/high/Integer-Overflow/","title":"Integer Overflow and Underflow","text":"<pre><code>id: TBA\ntitle: Integer Overflow and Underflow in Arithmetic Operations\nseverity: H\ncategory: arithmetic\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Incorrect state updates or fund miscalculations\nstatus: draft\ncomplexity: low\nattack_vector: external\nmitigation_difficulty: easy\nversions: [\"&gt;=0.4.0\", \"&lt;0.8.0\"]\ncwe: CWE-190\nswc: SWC-101\n</code></pre>"},{"location":"vuln-db/high/Integer-Overflow/#description","title":"\ud83d\udcdd Description","text":"<ul> <li>Integer overflow and underflow occur when arithmetic operations exceed the maximum or minimum value of the data type. In Solidity versions prior to 0.8.0, arithmetic operations on <code>uint</code> or <code>int</code> types do not automatically revert on overflow or underflow. </li> <li>This can be exploited to bypass balances, mint excess tokens, or cause denial of service via incorrect logic paths.</li> </ul>"},{"location":"vuln-db/high/Integer-Overflow/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>contract Token {\n    mapping(address =&gt; uint256) public balances;\n\n    function transfer(address to, uint256 amount) external {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient\");\n        balances[msg.sender] -= amount; // underflow if amount &gt; balance\n        balances[to] += amount;         // overflow possible here too\n    }\n}\n</code></pre>"},{"location":"vuln-db/high/Integer-Overflow/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<p>Step-by-step exploit process:</p> <ul> <li>Attacker calls transfer() with amount &gt; balances[msg.sender].</li> <li>If overflow/underflow checks are not enforced, subtraction wraps around to a huge value.</li> <li>balances[msg.sender] becomes very large; balances[to] also overflows.</li> <li>Attacker gains an unintended balance or breaks accounting logic.</li> </ul> <p>Assumptions:</p> <ul> <li>Contract is compiled with Solidity &lt;0.8.0.</li> <li>No usage of SafeMath or manual overflow checks.</li> </ul>"},{"location":"vuln-db/high/Integer-Overflow/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>// Solidity &gt;=0.8.0 has built-in overflow checks\ncontract SafeToken {\n    mapping(address =&gt; uint256) public balances;\n\n    function transfer(address to, uint256 amount) external {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient\");\n        unchecked {\n            balances[msg.sender] -= amount;\n            balances[to] += amount;\n        }\n    }\n}\n</code></pre> <pre><code>import \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract SafeToken {\n    using SafeMath for uint256;\n    mapping(address =&gt; uint256) public balances;\n\n    function transfer(address to, uint256 amount) external {\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        balances[to] = balances[to].add(amount);\n    }\n}\n</code></pre>"},{"location":"vuln-db/high/Integer-Overflow/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/high/Integer-Overflow/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Use Solidity &gt;=0.8.0, which includes built-in overflow/underflow checks.</li> <li>For older versions, use OpenZeppelin\u2019s SafeMath library.</li> <li>Avoid unchecked arithmetic unless performance-justified and safe.</li> </ul>"},{"location":"vuln-db/high/Integer-Overflow/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Write invariant tests for balance and supply correctness.</li> <li>Perform fuzzing to explore large input edge cases.</li> </ul>"},{"location":"vuln-db/high/Integer-Overflow/#detection-methods","title":"Detection Methods","text":"<ul> <li>Slither: arithmetic, unprotected-arithmetic detectors.</li> <li>Mythril, Echidna: symbolic and fuzzing-based overflow detection.</li> <li>Manual audit of arithmetic hotspots (balance, supply, loop counters).</li> </ul>"},{"location":"vuln-db/high/Integer-Overflow/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<ul> <li>Name: BeautyChain Token Overflow </li> <li>Date: 2018-04-22 </li> <li>Loss: Unlimited tokens minted </li> <li> <p>Post-mortem: Link to post-mortem </p> </li> <li> <p>Name: SMT Token Overflow Exploit</p> </li> <li>Date: 2018-04-26 </li> <li>Loss: Unlimited minting </li> <li>Post-mortem: Link to post-mortem </li> </ul>"},{"location":"vuln-db/high/Integer-Overflow/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>SWC-101: Integer Overflow and Underflow </li> <li>OpenZeppelin \u2013 SafeMath Documentation </li> <li>Solidity Docs \u2013 Arithmetic Safety in &gt;=0.8.0 </li> </ul>"},{"location":"vuln-db/high/Integer-Overflow/#vulnerability-report","title":"\u2705 Vulnerability Report","text":"<pre><code>id: TBA\ntitle: Integer Overflow and Underflow in Arithmetic Operations\nseverity: H\nscore:\nimpact: 5         \nexploitability: 4 \nreachability: 4   \ncomplexity: 2     \ndetectability: 4  \nfinalScore: 4.3\n</code></pre>"},{"location":"vuln-db/high/Integer-Overflow/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<ul> <li>Impact: Incorrect balances can lead to financial loss, infinite token minting, or denial of service.</li> <li>Exploitability: Easy in pre-0.8.0 contracts without SafeMath; requires only a crafted input.</li> <li>Reachability: Affects core logic like transfers, staking, accounting.</li> <li>Complexity: Attack is input-only; no contract interaction needed.</li> <li>Detectability: Slither, Mythril, and static analyzers reliably catch this if not suppressed.</li> </ul>"},{"location":"vuln-db/high/Overview/","title":"\ud83d\udd25 High Severity","text":"<ul> <li> <p>Critical flaws that can cause direct loss of funds, protocol failure, or admin takeovers. Must be fixed immediately.</p> </li> <li> <p>A single exploit can compromise entire contract balances or drain user assets.</p> </li> <li> <p>Often publicly detectable and quickly exploitable once deployed.</p> </li> <li> <p>Can undermine trust in the protocol and result in legal or reputational damage.</p> </li> <li> <p>Exploits are typically non-reversible on-chain once triggered.</p> </li> <li> <p>May allow attackers to escalate privileges, gaining unauthorized control over sensitive functions.</p> </li> <li> <p>Examples: Reentrancy, access control bugs, oracle manipulation, flash loan abuse, proxy upgrade misuse.</p> </li> </ul>"},{"location":"vuln-db/high/Reentrancy/","title":"Reentrancy Vulnerability","text":"<pre><code>id: TBA\ntitle: Reentrancy on External Contract Calls\nseverity: H\ncategory: reentrancy\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Repeated unauthorized state execution\nstatus: draft\ncomplexity: medium\nattack_vector: external\nmitigation_difficulty: easy\nversions: [\"&gt;=0.4.0\", \"&lt;0.8.21\"]\ncwe: CWE-841\nswc: SWC-107\n</code></pre>"},{"location":"vuln-db/high/Reentrancy/#description","title":"\ud83d\udcdd Description","text":"<ul> <li>Reentrancy is a critical vulnerability where an external call is made before internal state changes are finalized, allowing malicious contracts to re-enter the vulnerable function repeatedly. </li> <li>This can lead to double-withdrawals, drained funds, or broken invariants. </li> <li>It is most common in fallback functions or when using <code>call</code>, <code>send</code>, or <code>transfer</code> without proper access control and state ordering.</li> </ul>"},{"location":"vuln-db/high/Reentrancy/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>contract ReentrancyVuln {\n    mapping(address =&gt; uint256) public balances;\n\n    function withdraw() public {\n        require(balances[msg.sender] &gt; 0, \"No balance\");\n        payable(msg.sender).call{value: balances[msg.sender]}(\"\"); // reentrancy point\n        balances[msg.sender] = 0; // state change after external call\n    }\n\n    receive() external payable {\n        balances[msg.sender] += msg.value;\n    }\n}\n</code></pre>"},{"location":"vuln-db/high/Reentrancy/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<p>Step-by-step exploit process:</p> <ol> <li>Attacker deposits some ETH.</li> <li>Attacker\u2019s fallback contract calls withdraw() and during call{value: ...}, re-enters withdraw() again.</li> <li>Since balances[msg.sender] has not been zeroed, attacker withdraws repeatedly.</li> <li>Contract balance is drained before state is updated.</li> </ol> <p>Assumptions:</p> <ul> <li>No reentrancyGuard or Checks-Effects-Interactions pattern.</li> <li>Attacker uses a malicious contract with a fallback function.</li> </ul>"},{"location":"vuln-db/high/Reentrancy/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SafeWithdraw is ReentrancyGuard {\n    mapping(address =&gt; uint256) public balances;\n\n    function withdraw() public nonReentrant {\n        uint256 amount = balances[msg.sender];\n        require(amount &gt; 0, \"No balance\");\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n\n    receive() external payable {\n        balances[msg.sender] += msg.value;\n    }\n}\n</code></pre>"},{"location":"vuln-db/high/Reentrancy/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/high/Reentrancy/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Use Checks-Effects-Interactions pattern: update state before external calls.</li> <li>Use ReentrancyGuard modifier from OpenZeppelin.</li> <li>Avoid calling external contracts unless strictly necessary.</li> </ul>"},{"location":"vuln-db/high/Reentrancy/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Use transfer() or send() for fixed-gas payouts, if compatible.</li> <li>If using call(), wrap with nonReentrant and restrict fallbacks.</li> <li>Monitor unusual recursive call patterns in logs.</li> </ul>"},{"location":"vuln-db/high/Reentrancy/#detection-methods","title":"Detection Methods","text":"<ul> <li>Slither: reentrancy-eth detector.</li> <li>Mythril: symbolic path analysis for reentrant logic.</li> <li>Manual inspection of call, delegatecall, or fallback flows.</li> </ul>"},{"location":"vuln-db/high/Reentrancy/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<ul> <li>Name: The DAO Hack</li> <li>Date: 2016-06-17 </li> <li>Loss: ~$60M </li> <li> <p>Post-mortem: Link to post-mortem -</p> </li> <li> <p>Name: dForce/Lendf.Me Reentrancy Attack </p> </li> <li>Date: 2020-04-19 </li> <li>Loss: ~$25M</li> <li>Post-mortem: Link to post-mortem </li> </ul>"},{"location":"vuln-db/high/Reentrancy/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>SWC-107: Reentrancy </li> <li>OpenZeppelin Docs: ReentrancyGuard </li> <li>Trail of Bits: Understanding Reentrancy </li> </ul> <pre><code>id: TBA\ntitle: Reentrancy on External Contract Calls\nseverity: H\nscore:\nimpact: 5         \nexploitability: 5 \nreachability: 4   \ncomplexity: 3     \ndetectability: 3  \nfinalScore: 4.5\n</code></pre>"},{"location":"vuln-db/high/Reentrancy/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<ul> <li>Impact: A successful exploit can fully drain contract funds.</li> <li>Exploitability: Publicly known, simple to exploit if protections are absent.</li> <li>Reachability: Withdrawals, payments, and callbacks often expose this.</li> <li>Complexity: Requires attacker contract with fallback logic.</li> <li>Detectability: Tools detect reentrancy, but may miss second-order paths.</li> </ul>"},{"location":"vuln-db/high/denial-of-service/","title":"Denial of Service","text":"<pre><code>id: TBA\ntitle: Denial of Service via Unbounded Loop \nseverity: H\ncategory: denial-of-service\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Contract becomes unusable or stuck\nstatus: draft\ncomplexity: low\nattack_vector: external\nmitigation_difficulty: medium\nversions: [\"&gt;=0.4.0\", \"&lt;0.8.21\"]\ncwe: CWE-400\nswc: SWC-113\n</code></pre>"},{"location":"vuln-db/high/denial-of-service/#description","title":"\ud83d\udcdd Description","text":"<ul> <li>Denial of Service (DoS) in smart contracts occurs when an attacker can prevent legitimate users from interacting with a contract, either temporarily or permanently. </li> <li> <p>This can be achieved by exploiting resource-intensive operations (e.g., unbounded loops), failing external calls, unexpected reverts, or storage manipulation that causes subsequent operations to fail.</p> </li> <li> <p>In Ethereum, since each transaction has a gas limit, a common DoS vector is introducing logic that exceeds the block gas limit or causes reversion due to invalid assumptions (like looping through a growing array).</p> </li> </ul>"},{"location":"vuln-db/high/denial-of-service/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>mapping(address =&gt; uint[]) public userDeposits;\n\nfunction withdrawAll() external {\n    uint[] storage deposits = userDeposits[msg.sender];\n    for (uint i = 0; i &lt; deposits.length; i++) {\n        _processWithdrawal(deposits[i]); // Assume this costs significant gas\n    }\n    delete userDeposits[msg.sender];\n}\n</code></pre>"},{"location":"vuln-db/high/denial-of-service/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<p>Step-by-step exploit process:</p> <ol> <li> <p>Attacker makes hundreds or thousands ...[msg.sender].</p> </li> <li> <p>Calls withdrawAll() which loops over all entries...</p> </li> <li> <p>The loop execution exceeds the block gas limit \u2192 reverts.</p> </li> <li> <p>The attacker is now permanently locked out... </p> </li> </ol> <p>Assumptions:</p> <ul> <li> <p>The contract allows unlimited or unbounded entries into arrays or mappings.</p> </li> <li> <p>There is no gas-bound safety mechanism in looping constructs.</p> </li> </ul>"},{"location":"vuln-db/high/denial-of-service/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>function withdrawBatch(uint start, uint end) external {\n    uint[] storage deposits = userDeposits[msg.sender];\n    require(end &lt;= deposits.length, \"Invalid end index\");\n\n    for (uint i = start; i &lt; end; i++) {\n        _processWithdrawal(deposits[i]);\n    }\n\n    if (end == deposits.length) {\n        delete userDeposits[msg.sender];\n    }\n}\n</code></pre>"},{"location":"vuln-db/high/denial-of-service/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/high/denial-of-service/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Avoid unbounded loops in external/public functions.</li> <li>Introduce batching mechanisms (e.g., start and end indices).</li> <li>Set gas guards and enforce maximum data sizes where feasible.</li> </ul>"},{"location":"vuln-db/high/denial-of-service/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Implement rate limiting or per-call caps.</li> <li>Use gas estimation during testing to simulate worst-case  scenarios.</li> </ul>"},{"location":"vuln-db/high/denial-of-service/#detection-methods","title":"Detection Methods","text":"<ul> <li>Detect via static analysis tools (e.g., Slither: unbounded-loop, dos detectors).</li> <li>Fuzzing and gas profiling during QA.</li> <li>Formal verification of loop safety and invariants.</li> </ul>"},{"location":"vuln-db/high/denial-of-service/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<ul> <li>GovernMental (2016): Attackers used large data insertion to block contract execution.</li> <li>Parity Multisig (2017): Vulnerability in library handling resulted in contract lockout.</li> <li> <p>SpankChain (2018): DoS via unexpected reverts in fallback calls.</p> </li> <li> <p>Name: GovernMental DoS Vulnerability  </p> </li> <li>Date: 2016-06-11  </li> <li>Loss: N/A  </li> <li>Post-mortem: Link to post-mortem</li> </ul>"},{"location":"vuln-db/high/denial-of-service/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li> <p>SWC-113: DoS with Block Gas Limit</p> </li> <li> <p>Ethereum Smart Contract Best Practices \u2013 Denial of Service</p> </li> <li> <p>Slither Docs \u2013 Detecting DoS</p> </li> <li> <p>SWC-113: DoS with Block Gas Limit</p> </li> <li>Ethereum Smart Contract Best Practices \u2013 Denial of Service</li> <li>Slither Docs \u2013 Detecting DoS</li> </ul>"},{"location":"vuln-db/high/denial-of-service/#vulnerability-report","title":"\u2705 Vulnerability Report","text":"<pre><code>id: vuln__denial_of_service\ntitle: Denial of Service\nseverity: H\nscore:\nimpact: &lt;5&gt;        \nexploitability: &lt;4&gt; \nreachability: &lt;5&gt;   \ncomplexity: &lt;1&gt;     \ndetectability: &lt;3&gt;  \nfinalScore: &lt;4.3&gt;\n</code></pre>"},{"location":"vuln-db/high/denial-of-service/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<ul> <li>Impact: A well-crafted DoS can freeze user funds or key contract functionality, leading to major trust and financial loss.</li> <li>Exploitability: The attack can be triggered externally with minimal effort (e.g., looping, reverting).</li> <li>Reachability: Public/external functions without restrictions can be exploited at will.</li> <li>Complexity: Attack only requires interacting with the contract normally (e.g., through deposits or submissions).</li> <li>Detectability: While many tools detect unbounded loops, nuanced cases (e.g., user-sourced data) may be overlooked without manual review.</li> </ul>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/","title":"Gas Inefficiencies","text":"<pre><code>id: TBA\ntitle: Gas Inefficiencies via Suboptimal Solidity Patterns\nseverity: L\ncategory: gas-optimization\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Increased gas cost for users and contract operations\nstatus: draft\ncomplexity: low\nattack_vector: internal\nmitigation_difficulty: easy\nversions: [\"&gt;=0.4.0\", \"&lt;0.8.21\"]\ncwe: CWE-398\nswc: SWC-135\n</code></pre>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#description","title":"\ud83d\udcdd Description","text":"<ul> <li>Gas inefficiencies refer to non-optimal code patterns in Solidity that unnecessarily increase transaction costs.       </li> <li>While they may not introduce direct security risks or logic errors, they degrade user experience, bloat the blockchain, and waste funds over time. </li> <li>Common patterns include repeated state writes, unindexed events, unnecessary storage access, and bad data structures (e.g., dynamic arrays vs. mappings).</li> </ul>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>contract Inefficient {\n    uint public total;\n\n    function updateTotal(uint[] calldata nums) external {\n        for (uint i = 0; i &lt; nums.length; i++) {\n            total += nums[i]; // repeated storage writes\n        }\n    }\n}\n</code></pre>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<p>Step-by-step inefficiency scenario:</p> <ol> <li>A user calls updateTotal() with 100 items...</li> <li>For each iteration, total += nums[i] performs a separate SLOAD and SSTORE...</li> <li>Gas fees are significantly higher than needed, harming user and contract throughput...</li> </ol> <p>Assumptions:</p> <ul> <li>The contract performs heavy operations in loops.</li> <li>Storage slots are accessed or written repeatedly without caching.</li> </ul>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>function updateTotal(uint[] calldata nums) external {\n    uint _total = total; // load once into memory\n    for (uint i = 0; i &lt; nums.length; i++) {\n        _total += nums[i];\n    }\n    total = _total; // store once\n}\n</code></pre>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Cache storage variables in memory during loops.</li> <li>Use unchecked blocks when overflow checks are unnecessary.</li> <li>Avoid redundant computations inside loops.</li> </ul>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Prefer mappings over arrays for sparse data.</li> <li>Batch updates with fewer storage writes.</li> <li>Use constant and immutable variables where applicable.</li> </ul>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#detection-methods","title":"Detection Methods","text":"<ul> <li>Slither: gas-cost, uninitialized-state, inefficient-loop detectors.</li> <li>Manual audit using gas profiling tools like Remix or Tenderly. -Optimizer analysis via solc --optimize and bytecode diffing.</li> </ul>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<ul> <li>Name: ZRX Token Transfer Loop Bug </li> <li>Date: 2018-08-19 </li> <li>Loss: N/A (No hack, but excessive gas burned)  </li> <li>Post-mortem: Link to post-mortem </li> </ul>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>SWC-135: Code With No Effects </li> <li>Solidity Docs \u2013 Gas Optimization Tips </li> <li>Slither \u2013 Gas Optimization Detectors</li> </ul>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#vulnerability-report","title":"\u2705 Vulnerability Report","text":"<pre><code>id: vuln__gas_inefficiencies\ntitle: Gas Inefficiencies\nseverity: L\nscore:\nimpact: 2        \nexploitability: 1 \nreachability: 4   \ncomplexity: 1     \ndetectability: 5  \nfinalScore: 2.0\n</code></pre>"},{"location":"vuln-db/low/Gas-Inefficiencies-attack/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<p>-Impact: Leads to high transaction costs and inefficiency, but no loss of funds or functionality.</p> <p>-Exploitability: Cannot be exploited in the traditional sense; rather, it causes passive economic degradation.</p> <p>-Reachability: Affects regularly used public/external functions in most contracts.</p> <p>-Complexity: No effort required by the user; impact is implicit in normal use.</p> <p>-Detectability: Readily caught by Slither, Remix, and manual gas profiling.</p>"},{"location":"vuln-db/low/Overview/","title":"\ud83d\udfe2 Low Severity","text":"<ul> <li> <p>Minor issues that do not result in immediate financial loss or protocol compromise.</p> </li> <li> <p>Often related to code quality, developer best practices, or non-critical inefficiencies.</p> </li> <li> <p>May include things like improper event logging, unused variables, or lack of input validation on non-sensitive functions.</p> </li> <li> <p>Generally non-exploitable or only exploitable under rare, controlled conditions.</p> </li> <li> <p>Fixes are recommended to improve maintainability, audit clarity, or prevent future escalation.</p> </li> <li> <p>Low severity issues do not impact core logic or asset flows, but cleaning them up contributes to long-term protocol security hygiene.</p> </li> </ul>"},{"location":"vuln-db/medium/Overview/","title":"\ud83d\udfe0 Medium Severity","text":"<ul> <li> <p>May result in limited financial impact under specific conditions but usually not catastrophic.</p> </li> <li> <p>Exploitation often requires multiple conditions to align, such as specific user behavior or system state.</p> </li> <li> <p>Might affect functionality or reliability without directly causing fund loss.</p> </li> <li> <p>Could lead to privilege escalation or indirect manipulation if chained with other vulnerabilities.</p> </li> <li> <p>Not easily exploitable on its own, but might be used in multi-step attacks.</p> </li> <li> <p>Fixes are important but may not require immediate emergency response.</p> </li> <li> <p>Often discovered during thorough audits, not immediately obvious in casual reviews.</p> </li> <li> <p>May degrade user trust if exploited, even if impact is moderate.</p> </li> <li> <p>Includes misconfigurations, improper checks, and outdated logic that could become critical over time.</p> </li> <li> <p>Should be prioritized for patching after high severity issues are addressed to reduce compound risk.</p> </li> </ul>"},{"location":"vuln-db/medium/logic-errors/","title":"Logic Errors in Contract Conditions","text":"<pre><code>id: TBA\ntitle: Logic Errors in Contract Conditions or Calculations\nseverity: M\ncategory: logic-error\nlanguage: solidity\nblockchain: [ethereum]\nimpact: Unintended behavior or incorrect fund/state handling\nstatus: draft\ncomplexity: medium\nattack_vector: internal\nmitigation_difficulty: medium\nversions: [\"&gt;=0.4.0\", \"&lt;0.8.21\"]\ncwe: CWE-840\nswc: SWC-124\n</code></pre>"},{"location":"vuln-db/medium/logic-errors/#description","title":"\ud83d\udcdd Description","text":"<ul> <li>Logic errors occur when the contract code executes successfully but the implemented logic does not match the intended behavior. </li> <li>These issues are often found in conditionals, arithmetic operations, loop boundaries, state updates, or access control. </li> <li>Unlike syntax or runtime errors, logic flaws don\u2019t revert\u2014making them harder to detect but potentially harmful in production.</li> </ul>"},{"location":"vuln-db/medium/logic-errors/#vulnerable-code","title":"\ud83d\udea8 Vulnerable Code","text":"<pre><code>contract RewardVault {\n    mapping(address =&gt; uint256) public balances;\n\n    function claimReward() external {\n        require(balances[msg.sender] &gt; 0, \"No reward\");\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(balances[msg.sender]); // BUG: transfers zero\n    }\n}\n</code></pre>"},{"location":"vuln-db/medium/logic-errors/#exploit-scenario","title":"\ud83e\uddea Exploit Scenario","text":"<ol> <li>Step-by-step exploit process:</li> <li>User has a positive reward balance.</li> <li>Calls claimReward().</li> <li>Balance is reset before transfer \u2192 sends 0 ETH.</li> <li>Funds remain trapped in the contract indefinitely.</li> </ol> <p>Assumptions:</p> <ul> <li>The contract sets balances during other user interactions.</li> <li>No fallback to manually recover or fix state errors.</li> </ul>"},{"location":"vuln-db/medium/logic-errors/#fixed-code","title":"\u2705 Fixed Code","text":"<pre><code>function claimReward() external {\n    uint256 reward = balances[msg.sender];\n    require(reward &gt; 0, \"No reward\");\n    balances[msg.sender] = 0;\n    payable(msg.sender).transfer(reward);\n}\n</code></pre>"},{"location":"vuln-db/medium/logic-errors/#prevention","title":"\ud83d\udee1\ufe0f Prevention","text":""},{"location":"vuln-db/medium/logic-errors/#primary-defenses","title":"Primary Defenses","text":"<ul> <li>Carefully order operations (read before write).</li> <li>Use clear variable naming and intermediate variables for clarity.</li> <li>Test all edge cases, including zero values and boundary conditions.</li> </ul>"},{"location":"vuln-db/medium/logic-errors/#additional-safeguards","title":"Additional Safeguards","text":"<ul> <li>Implement invariant checks and assertions (assert()).</li> <li>Write unit + integration tests for every critical business function.</li> <li>Perform formal verification for critical logic flows.</li> </ul>"},{"location":"vuln-db/medium/logic-errors/#detection-methods","title":"Detection Methods","text":"<ul> <li>Hardhat/Waffle test coverage on all execution paths.</li> <li>Slither: unused-return, incorrect-transfer-order, and logic detectors.</li> <li>Symbolic execution via tools like Mythril or Manticore.</li> </ul>"},{"location":"vuln-db/medium/logic-errors/#historical-exploits","title":"\ud83d\udd70\ufe0f Historical Exploits","text":"<ul> <li>Name: Rubixi Early Ownership Bug </li> <li>Date: 2016-05-03 </li> <li>Loss: N/A</li> <li> <p>Post-mortem: Link to post-mortem</p> </li> <li> <p>Name: YAM Finance Overflow Bug </p> </li> <li>Date: 2020-08-13 </li> <li>Loss: Protocol disabled, $750K lost</li> <li>Post-mortem: Link to post-mortem --&gt;</li> </ul>"},{"location":"vuln-db/medium/logic-errors/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>SWC-124: Incorrect Inheritance Order or Logic</li> <li>Trail of Bits: Logic Bugs in Smart Contracts </li> <li>OpenZeppelin \u2013 Avoiding Logic Errors </li> </ul>"},{"location":"vuln-db/medium/logic-errors/#vulnerability-report","title":"\u2705 Vulnerability Report","text":"<pre><code>id: vuln__005\ntitle: Logic Errors in Contract Conditions or Calculations\nseverity: M\nscore:\nimpact: 3         \nexploitability: 3\nreachability: 4   \ncomplexity: 2     \ndetectability: 3  \nfinalScore: 3.15\n</code></pre>"},{"location":"vuln-db/medium/logic-errors/#justifications-analysis","title":"\ud83d\udcc4 Justifications &amp; Analysis","text":"<ul> <li>Impact: Can block fund withdrawals, misassign roles, or result in protocol malfunction.</li> <li>Exploitability: Triggered by standard user interactions with crafted input or timing.</li> <li>Reachability: Often in user-facing functions like withdraw(), claim(), or mint().</li> <li>Complexity: May require understanding of internal state and order of operations.</li> <li>Detectability: Harder to catch unless tests or formal analysis are thorough.</li> </ul>"}]}